template <size_t N>
		void fill(Particle* (&particleptrs)[N]) {
			root = fit(particleptrs);
			for (Particle* const& particleptr : particleptrs) {
				insert(particleptr);
			}
		}
		template <size_t N>
		void fill(Particle particles[N]) {
			root = fit(particles);
			for (const Particle& particle : particles) {
				insert(particle);
			}
		}
		void fill(Particle** const& particleptrs) {
			root = fit(particleptrs);
			for (Particle* const& particleptr : particleptrs) {
				insert(particleptr);
			}
		}
		Node<Particle>* fit(Particle** const& particleptrs) {
			vec2f center;
			vec2f magMax;
			return new Node<Particle>(center, magMax);
		}
		template <size_t N>
		Node<Particle>* fit(Particle* (&particleptrs)[N]) const {
			vec2f center = vec2f();
			for (Particle* const& particleptr : particleptrs) {
				center += particleptr->position;
			}
			center /= N;
			float magMax = 0.0f;
			for (Particle* const& particleptr : particleptrs) {
				magMax = particleptr->position.mag() > magMax ? particleptr->position.mag() : magMax;
			}
			return new Node<Particle>(center, magMax);
		}
		template <size_t N>
		Node<Particle>* fit(std::vector<Particle*> particleptrs[N]) const {
			vec2f center = vec2f();
			for (Particle* const& particleptr : particleptrs) {
				center += particleptr->position;
			}
			center /= N;
			float magMax = 0.0f;
			for (Particle* const& particleptr : particleptrs) {
				magMax = particleptr->position.mag() > magMax ? particleptr->position.mag() : magMax;
			}
			return new Node<Particle>(center, magMax);
		}
		template <size_t N>
		Node<Particle>* fit(Particle particles[N]) const {
			vec2f center = vec2f();
			for (Particle const& particle : particles) {
				center += particle.position;
			}
			center /= N;
			float magMax = 0.0f;
			for (Particle const& particle : particles) {
				float tempMag = particle.position.mag();
				magMax = tempMag > magMax ? tempMag : magMax;
			}
			return new Node<Particle>(center, magMax);

//const float posRange = 1E9;
	//const float massLower = 1E23f;
	//const float massHigher = 1E26f;
	//const unsigned int nBodies = 50;
	//Body* bodies = new Body[nBodies];
	//for (int i = 0; i < nBodies; i++) {
	//	bodies[i].position = vec2f::random(-posRange, posRange);
	//	bodies[i].mass = RandomFloat(massLower, massHigher);
	//}
	//
	////Tree::BHtree<Particle> tree;
	////tree.fill(bodies, nBodies);
	//Tree::BHtree<Particle> tree(bodies, nBodies);
	//tree.fill(bodies, nBodies);
	//tree.clear();
	//tree.fill(bodies, nBodies);
	//std::cout << "# of Nodes: " << tree.countNodes() << std::endl;
	//std::cout << sizeof(Particle) * nBodies / 1000000.0f << "Mb of particles" << std::endl;
	//std::cout << tree.getSize() / 1000000.0f << "Mb of nodes" << std::endl;
	//std::cout << sizeof(Tree::Node<Particle>) << std::endl;